{"version":3,"sources":["Components/Login.tsx","Actions/auth.ts","Functions/requests.ts","Actions/albums.ts","Actions/songs.ts","Actions/songsQueue.ts","Actions/websocket.ts","Actions/index.ts","Actions/activeSong.ts","Actions/functions.ts","Actions/user.ts","Stores/store.ts","Reducers/auth.ts","Reducers/user.ts","Reducers/albums.ts","Reducers/songs.ts","Reducers/songsState.ts","Reducers/websocket.ts","Reducers/songsQueue.ts","Stores/initialState.ts","Components/Presentational/Song.tsx","Components/Containers/SongList.tsx","Components/Containers/MusicPlayer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["linkContainer","css","height","background","display","justifyContent","alignItems","width","link","fontSize","Login","_Component","_getPrototypeOf2","_this","Object","classCallCheck","this","_len","arguments","length","args","Array","_key","possibleConstructorReturn","getPrototypeOf","call","apply","concat","clientId","responseType","redirectURL","window","location","origin","linkToSpotifyAuth","inherits","createClass","key","value","console","log","core_browser_esm","href","className","Component","AuthRedirection","_Component2","_getPrototypeOf3","_this2","_len3","_key3","getToken","props","token","undefined","hash","split","saveToken","convertToken","status","createdAt","moment","expiresAt","axios","defaults","baseURL","saveUserAlbums","albums","type","Action","SAVE_ALBUMS","fetchUserAlbums","Actions_albums_fetchUserAlbums","_callee","regenerator_default","a","wrap","_context","prev","next","store","getState","get","headers","Authorization","then","response","data","items","error","catch","e","sent","abrupt","stop","getUserAlbums","_getUserAlbums","_callee2","_context2","ALBUMS_FETCH_FAILED","saveSongs","songs","SAVE_SONGS","fetchUserSongs","_x","_fetchUserSongs","paginationStatus","total","offset","map","item","name","artists","track","id","thumbnail_url","album","images","url","duration","formatted_name","artist","join","isReady","SongReadiness","NOT_READY","getUserFavouriteSongs","_x2","_getUserFavouriteSongs","dispatch","songsChunk","firstFetch","SONGS_FETCH_FAILED","toggleSong","songName","TOGGLE_SONG_IN_QUEUE","ws","WebSocket","setSocketError","WS_CONNECTION_FAILED","TokenStatus","setActiveSong","song","SET_ACTIVE_SONG","scheduleSong","thumbnailUrl","action","payload","send","JSON","stringify","sendSong","isObjectEmpty","obj","entries","constructor","saveUserData","user","SAVE_USER_PROFILE","getUserInformations","_getUserInformations","fetchUserInformations","display_name","USER_FETCH_FAILED","Actions_user_fetchUserInformations","onopen","event","notification","success","message","description","WS_CONNECTION_SUCCESSFULL","onclose","onerror","onmessage","parse","nextSong","next_song","open","DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE","queueState","queue","songs_queue","SAVE_SONGS_IN_QUEUE","activeSong","active_song","downloadedSong","READY","failedSong","CANT_DOWNLOAD","loggerMiddleware","createLogger","app","combineReducers","state","SAVE_TOKEN","DELETE_TOKEN","REFRESH_TOKEN","websocketConnected","songsQueue","ADD_SONGS_TO_QUEUE","objectSpread","slice","createStore","previousSongs","applyMiddleware","thunkMiddleware","formatText","maxNumberOfLetters","innerWidth","SongItem","list","Item","onClick","Meta","avatar","src","title","SongQueueItem","readiness","icon","progress","failed","spin","formatProgress","color","SelectedList","Search","Input","SongList","currentPage","window_height","innerHeight","window_width","selectedList","YourSongs","searchbarValue","indexesToFade","getData","filter","toLowerCase","includes","handleTransition","SongsQueue","menu","setState","selectedKeys","mode","placeholder","size","onChange","target","onSearch","locale","emptyText","bordered","itemLayout","dataSource","renderItem","Song_SongQueueItem","Song_SongItem","pagination","pageSize","simple","showQuickJumper","SongListComponent","connect","convertTime","time","seconds","Math","floor","mins","secondsRemaining","musicPlayer","marginLeft","marginRight","flexWrap","padding","MusicPlayer","clicked","isSongSet","MusicPlayer_ActiveSong","MusicPlayer_SongTimer","songTimer","SongTimer","setInterval","defineProperty","ActiveSong","shape","style","paddingLeft","MusicPlayerComponent","previousSong","App","didRouteChange","getTokenFromLocalStorage","EXPIRED","fetchFavouriteSongs","history","push","react_default","createElement","Switch","Route","path","component","socketConnected","Root","es","BrowserRouter","AppCore","mapStateToProps","_fetchUserInformations","asyncToGenerator","mark","t0","t1","_fetchUserAlbums","_fetchFavouriteSongs","_callee3","_context3","isBefore","tokenToSave","OK","add","AuthRedirectionComponent","Boolean","hostname","match","config","placement","bottom","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b23636dc.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { RouteComponentProps } from \"react-router-dom\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\n\ninterface AuthProps extends RouteComponentProps {\n  saveToken: (token: string) => void;\n}\n\nconst linkContainer = css({\n  height: \"87vh\",\n  background: \"#282828\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  width: \"100%\"\n});\n\nconst link = css({\n  fontSize: \"2rem\"\n});\n\nexport class Login extends Component<AuthProps> {\n  clientId = \"d09edd82dac149a5b6f076515368e06d\";\n  responseType = \"token\";\n  redirectURL = window.location.origin;\n  linkToSpotifyAuth = `https://accounts.spotify.com/authorize?client_id=${\n    this.clientId\n  }&redirect_uri=${this.redirectURL}&response_type=${\n    this.responseType\n  }&scope=user-library-read`;\n\n  render() {\n    console.log(window.location);\n    return (\n      <div css={linkContainer}>\n        <a css={link} href={this.linkToSpotifyAuth} className=\"App-link\">\n          Login to spotify\n        </a>\n      </div>\n    );\n  }\n}\n\nexport class AuthRedirection extends Component<AuthProps> {\n  componentDidMount() {\n    this.getToken(this.props);\n  }\n  getToken = (props: AuthProps) => {\n    // get token from hash after redirection from spotify login page, after splitting it by = split it by & to remove next query parameter from it\n    const queryParams =\n      props.location.hash === undefined ? \"\" : props.location.hash;\n    const rawToken = queryParams.split(\"=\")[1] || \"\";\n    // token to return\n    const token = rawToken.split(\"&\")[0] || \"\";\n    // save token to global store\n    this.props.saveToken(token);\n  };\n\n  render() {\n    return <div>Authenticated</div>;\n  }\n}\n","import { Action, Token, StandardAction, TokenStatus, TokenFromLocalStorage } from \"./index\";\nimport * as store from \"store\";\nimport moment from \"moment\";\nimport { isObjectEmpty } from \"./index\";\n\nfunction convertToken(token: TokenFromLocalStorage): Token {\n    return {\n        value: token.value,\n        status: token.status,\n        createdAt: moment(token.createdAt),\n        expiresAt: moment(token.expiresAt),\n    }\n}\n\nexport function getTokenFromLocalStorage(): StandardAction<Token> {\n    const token: TokenFromLocalStorage = store.get(\"token\", {});\n    if (moment(token.expiresAt).isBefore(moment()) || isObjectEmpty(token)) {\n        return {\n            value: {\n                value: \"EXPIRED_TOKEN\",\n                status: TokenStatus.EXPIRED,\n                createdAt: moment(),\n                expiresAt: moment()\n            },\n            type: Action.SAVE_TOKEN\n        }\n    }\n    return {\n        value: convertToken(token),\n        type: Action.SAVE_TOKEN\n    }\n}\n\nexport function saveToken(token: string): StandardAction<Token> {\n    const tokenToSave: Token = {\n        value: token,\n        status: TokenStatus.OK,\n        createdAt: moment(),\n        expiresAt: moment().add(3600, \"seconds\")\n    };\n    // save token in local storage\n    store.set(\"token\", tokenToSave);\n    return {\n        value: tokenToSave,\n        type: Action.SAVE_TOKEN\n    }\n}\n\n\nexport function deleteToken(): StandardAction<Token> {\n    return {\n        value: {} as Token,\n        type: Action.DELETE_TOKEN\n    }\n}","import axios from \"axios\";\naxios.defaults.baseURL = \"https://api.spotify.com/v1\";\nexport default axios;\n","import { Album, StandardAction, Action, RequestData } from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\n\nexport function saveUserAlbums(albums: Album[]): StandardAction<Album[]> {\n    return {\n        value: albums,\n        type: Action.SAVE_ALBUMS\n    }\n}\n\nexport function albumsFetchFailed(): StandardAction<Album[]> {\n    return {\n        value: [],\n        type: Action.ALBUMS_FETCH_FAILED\n    }\n}\n\n\nexport async function fetchUserAlbums() {\n    const token = store.getState().token.value;\n    const albums = await axios.get<RequestData<Album>>(\"/me/playlists\", {\n        headers: {\n            'Authorization': `Bearer  ${token}`\n        }\n    }).then((response) => {\n        const { data } = response;\n        return { value: data.items, error: false } as Result<Album[]>;\n    }).catch(e => { return { error: true } as Result<Album[]> });\n    return albums;\n}\n\nexport async function getUserAlbums() {\n    const albums = await fetchUserAlbums();\n    if (albums.error) {\n        return albumsFetchFailed();\n    } else {\n        return saveUserAlbums(albums.value);\n    }\n}\n\n","import {\n  Album,\n  StandardAction,\n  Action,\n  Song,\n  SongsRequestData,\n  Artist,\n  SongReadiness,\n  PlainSong\n} from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\nimport { Dispatch } from \"react\";\nimport { AnyAction } from \"redux\";\n\nexport function saveSongs(songs: Song[]): StandardAction<Song[]> {\n  return {\n    value: songs,\n    type: Action.SAVE_SONGS\n  };\n}\n\nexport function songsFetchFailed(): StandardAction<Album[]> {\n  return {\n    value: [],\n    type: Action.SONGS_FETCH_FAILED\n  };\n}\n\ntype PaginationStatus = {\n  // total number of songs available\n  total: number;\n  // number of songs already downloaded\n  offset: number;\n  firstFetch: boolean;\n};\n\nfunction formatName(name: string, artists: Artist[]) {\n  return `${name} - ${artists.map(artist => artist.name).join(\", \")}`;\n}\n\nexport async function fetchUserSongs(paginationStatus: PaginationStatus) {\n  const token = store.getState().token.value;\n\n  // total number of songs\n  let total = 0;\n  const songs = await axios\n    .get<SongsRequestData>(\n      `/me/tracks?limit=50&offset=${paginationStatus.offset}`,\n      {\n        headers: {\n          Authorization: `Bearer  ${token}`\n        }\n      }\n    )\n    .then(response => {\n      const { data } = response;\n      total = data.total;\n      // unwrap songs from song containers\n      const songs: Song[] = data.items.map(item => {\n        const { track } = item;\n        return {\n          id: track.id,\n          name: track.name,\n          thumbnail_url: track.album.images[0].url,\n          duration: track.duration / 1000,\n          formatted_name: formatName(track.name, track.artists),\n          isReady: SongReadiness.NOT_READY,\n          artists: track.artists.map(artist => artist.name).join(\", \")\n        };\n      });\n      return { value: songs, error: false } as Result<Song[]>;\n    })\n    .catch(e => {\n      return { error: true } as Result<Song[]>;\n    });\n\n  // calculate next offset based on the previous ones and number of songs that we just fetched\n  return { songs, total, offset: paginationStatus.offset + songs.value.length };\n}\n\nexport async function getUserFavouriteSongs(dispatch: Dispatch<AnyAction>) {\n  let paginationStatus: PaginationStatus = {\n    total: 0,\n    offset: 0,\n    firstFetch: true\n  };\n  let songs: Song[] = [];\n\n  // fetch songs until all of\n  while (\n    paginationStatus.offset < paginationStatus.total ||\n    paginationStatus.firstFetch\n  ) {\n    // fetch next chunk of songs, function might only download 50 songs at once\n    const songsChunk = await fetchUserSongs(paginationStatus);\n    // throw an error action in case of errors\n    if (songsChunk.songs.error) {\n      dispatch(songsFetchFailed());\n    } else {\n      // set new pagination status with new offset which is an index from where next function will start fetching new songs\n      paginationStatus = {\n        offset: songsChunk.offset,\n        total: songsChunk.total,\n        firstFetch: false\n      };\n      songs = songs.concat(songsChunk.songs.value);\n      dispatch(saveSongs(songs));\n    }\n  }\n}\n","import { Action, Song, SongsQueueAction, SongReadiness } from \".\";\n\nexport function getSongsQueue() {}\n\nexport function addSongsToQueue(songs: Song[]): SongsQueueAction {\n  return {\n    type: Action.ADD_SONGS_TO_QUEUE,\n    songs\n  };\n}\n\nexport function saveSongsInQueue(songs: Song[]): SongsQueueAction {\n  return {\n    type: Action.SAVE_SONGS_IN_QUEUE,\n    songs\n  };\n}\n\nexport function deleteRecentActiveSongFromQueue(): SongsQueueAction {\n  return {\n    type: Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE\n  };\n}\n\n// toggle song\nexport function toggleSong(\n  songName: string,\n  isReady: SongReadiness\n): SongsQueueAction {\n  return {\n    type: Action.TOGGLE_SONG_IN_QUEUE,\n    isReady,\n    songName\n  };\n}\n","import { StandardAction, Action, Song, SongReadiness } from \"./index\";\nimport { store } from \"../Stores/index\";\nimport { setActiveSong } from \"./activeSong\";\nimport {\n  toggleSong,\n  saveSongsInQueue,\n  deleteRecentActiveSongFromQueue\n} from \"./songsQueue\";\nimport { notification } from \"antd\";\nexport const ws = new WebSocket(\"ws://127.0.0.1:8080/ws/\");\n\ntype WSAction = {\n  action: string;\n  success: boolean;\n  value: any;\n};\n\nfunction setSocketConnected(): StandardAction<boolean> {\n  return {\n    type: Action.WS_CONNECTION_SUCCESSFULL,\n    value: true\n  };\n}\n\nfunction setSocketError(): StandardAction<boolean> {\n  return {\n    type: Action.WS_CONNECTION_FAILED,\n    value: false\n  };\n}\n\nlet isSocketOpened = false;\n\nws.onopen = event => {\n  isSocketOpened = true;\n  notification.success({\n    message: \"Connection\",\n    description: \"Successfully connected to the home-fm-server.\"\n  });\n  store.dispatch(setSocketConnected());\n};\n\nws.onclose = event => {\n  isSocketOpened = false;\n  notification.error({\n    message: \"Connection\",\n    description: \"Diconnected from home-fm-server\"\n  });\n  store.dispatch(setSocketError());\n};\n\nws.onerror = event => {\n  notification.error({\n    message: \"Connection\",\n    duration: 10,\n    description: \"home-fm-server isn't turned on\"\n  });\n  store.dispatch(setSocketError());\n};\n\ntype Data<T> = {\n  value: T;\n};\n\ntype NextSong = {\n  next_song: Song;\n};\n\ntype QueueState = {\n  active_song: Song;\n  songs_queue: Song[];\n};\n\nws.onmessage = event => {\n  const data: WSAction = JSON.parse(event.data);\n  switch (data.action) {\n    case \"next_song\":\n      const songData: NextSong = data.value;\n      const nextSong = songData.next_song;\n      notification.open({\n        message: \"Now playing\",\n        description: `${nextSong.name} - ${nextSong.artists}`\n      });\n      handleNextSong(nextSong);\n      store.dispatch(deleteRecentActiveSongFromQueue());\n      break;\n    case \"queue_state\":\n      let queueState: QueueState = data.value;\n      const queue: Song[] = queueState.songs_queue;\n      store.dispatch(saveSongsInQueue(queue));\n      let activeSong: Song = queueState.active_song;\n      store.dispatch(setActiveSong(activeSong));\n      return;\n    case \"song_download_finished\":\n      let downloadedSong: Song = data.value;\n      store.dispatch(toggleSong(downloadedSong.name, SongReadiness.READY));\n      return;\n    case \"song_download_failed\":\n      let failedSong: Song = data.value;\n      store.dispatch(toggleSong(failedSong.name, SongReadiness.CANT_DOWNLOAD));\n      return;\n    case \"song_download_started\":\n      break;\n    default:\n  }\n};\n\nfunction handleNextSong(song: Song) {\n  store.dispatch(setActiveSong(song));\n}\n\nexport function sendSong(\n  songName: string,\n  artists: string,\n  thumbnailUrl: string\n) {\n  const data = {\n    action: \"request_song\",\n    payload: {\n      artists,\n      name: songName,\n      thumbnail_url: thumbnailUrl\n    }\n  };\n  ws.send(JSON.stringify(data));\n}\n\nfunction convertSongs(songs: Song[]) {}\n","import { Moment } from \"moment\";\n\nexport { saveToken, deleteToken, getTokenFromLocalStorage } from \"./auth\";\nexport { fetchUserAlbums, getUserAlbums } from \"./albums\";\nexport { getUserFavouriteSongs } from \"./songs\";\nexport { setActiveSong } from \"./activeSong\";\nexport { randomNumber, isObjectEmpty } from \"./functions\";\nexport { getUserInformations } from \"./user\";\nexport { ws } from \"./websocket\";\nexport type Token = {\n  value: string;\n  status: TokenStatus;\n  createdAt: Moment;\n  expiresAt: Moment;\n};\n\nexport type TokenFromLocalStorage = {\n  value: string;\n  status: TokenStatus;\n  createdAt: Date;\n  expiresAt: Date;\n};\n\nexport type User = {\n  display_name: string;\n};\n\nexport type StandardAction<T> = {\n  value: T;\n  type: Action;\n};\n\nexport type AddSongs = {\n  type: Action.ADD_SONGS_TO_QUEUE;\n  songs: Song[];\n};\n\nexport type ToggleSong = {\n  type: Action.TOGGLE_SONG_IN_QUEUE;\n  isReady: SongReadiness;\n  songName: string;\n};\n\nexport type SaveSongs = {\n  type: Action.SAVE_SONGS_IN_QUEUE;\n  songs: Song[];\n};\n\nexport type DeleteRecentActiveSong = {\n  type: Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE;\n};\n\nexport type SongsQueueAction =\n  | SaveSongs\n  | AddSongs\n  | ToggleSong\n  | DeleteRecentActiveSong;\n\nexport enum Action {\n  // token actions\n  SAVE_TOKEN,\n  DELETE_TOKEN,\n  REFRESH_TOKEN,\n  // user actions\n  SAVE_USER_PROFILE,\n  USER_FETCH_FAILED,\n  // albums actions\n  SAVE_ALBUMS,\n  ALBUMS_FETCH_FAILED,\n  // songs actions\n  SAVE_SONGS,\n  SONGS_FETCH_FAILED,\n  // activeSong actions\n  SET_ACTIVE_SONG,\n  // previous songs\n  PUSH_SONG,\n  POP_SONG,\n  // websocket actions\n  WS_CONNECTION_FAILED,\n  WS_CONNECTION_SUCCESSFULL,\n  // songs state\n  SAVE_SONGS_IN_QUEUE,\n  ADD_SONGS_TO_QUEUE,\n  TOGGLE_SONG_IN_QUEUE,\n  DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE\n}\n\nexport enum TokenStatus {\n  OK,\n  INVALID,\n  EXPIRED\n}\n\nexport type Album = {\n  name: string;\n  id: string;\n  images: Image[];\n  tracks: Tracks;\n};\n\n// request data type to unpack items from axios requests\nexport type RequestData<T> = {\n  items: T[];\n};\n\nexport type SongContainer = {\n  created_at: Date;\n  track: PlainSong;\n};\n\nexport interface SongsRequestData extends RequestData<SongContainer> {\n  // total number of songs user added to his library, used for pagination\n  total: number;\n}\n\n// object containing informations about api to fetch albums songs\nexport type Tracks = {\n  href: string;\n  total: number;\n};\n\nexport type Image = {\n  url: string;\n};\n\n// plain song object from spotify api\nexport type PlainSong = {\n  href: string;\n  name: string;\n  artists: Artist[];\n  album: Album;\n  id: string;\n  duration: number;\n  formatted_name: string;\n  // it's gonna be used in queue to determine whether server downloaded it already or not\n  isReady: SongReadiness;\n};\n\nexport type Song = {\n  name: string;\n  artists: string;\n  id: string;\n  duration: number;\n  formatted_name: string;\n  thumbnail_url: string;\n  // it's gonna be used in queue to determine whether server downloaded it already or not\n  isReady: SongReadiness;\n};\n\nexport enum SongReadiness {\n  READY,\n  NOT_READY,\n  CANT_DOWNLOAD\n}\n\nexport type Artist = {\n  name: string;\n};\n\nexport type SongsState = {\n  activeSong: Song;\n  previousSongs: Song[];\n};\n","import { Action, Song, StandardAction, randomNumber } from \"./index\";\nimport { sendSong } from \"./websocket\";\n\n// if pushToHistory equals true then song will be pushed to previousSongs array\nexport function setActiveSong(song: Song): StandardAction<Song> {\n  // whether we want to notify server about incoming song or not\n  return {\n    value: song,\n    type: Action.SET_ACTIVE_SONG\n  };\n}\n\nexport function scheduleSong(song: Song) {\n  sendSong(song.name, song.artists, song.thumbnail_url);\n}\n","// returns a number between min and max range\nexport function randomNumber(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nexport function isObjectEmpty(obj: any) {\n  if (obj === null) {\n    return true;\n  }\n  return Object.entries(obj).length === 0 && obj.constructor === Object;\n}\n","import { Action, User, StandardAction } from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\n\nexport function saveUserData(user: User): StandardAction<User> {\n  return {\n    value: user,\n    type: Action.SAVE_USER_PROFILE\n  };\n}\n\nexport function userFetchFailed(): StandardAction<User> {\n  return {\n    value: { display_name: \"\" },\n    type: Action.USER_FETCH_FAILED\n  };\n}\n\nexport async function getUserInformations(): Promise<StandardAction<User>> {\n  const user = await fetchUserInformations();\n  if (user.error) {\n    return userFetchFailed();\n  } else {\n    return saveUserData(user.value);\n  }\n}\n\nexport async function fetchUserInformations() {\n  const token = store.getState().token.value;\n  const user = await axios\n    .get<User>(\"/me\", {\n      headers: {\n        Authorization: `Bearer  ${token}`\n      }\n    })\n    .then(response => {\n      const { data } = response;\n      return { value: data, error: false } as Result<User>;\n    })\n    .catch(e => {\n      return { error: true } as Result<User>;\n    });\n  return user;\n}\n","import { createStore, combineReducers, applyMiddleware } from \"redux\";\nimport {\n  token,\n  user,\n  albums,\n  songs,\n  activeSong,\n  websocketConnected,\n  songsQueue\n} from \"../Reducers/index\";\nimport { initialState } from \"./index\";\nimport thunkMiddleware from \"redux-thunk\";\nimport { createLogger } from \"redux-logger\";\n\nconst loggerMiddleware = createLogger();\n\nconst app = combineReducers({\n  token,\n  user,\n  albums,\n  songs,\n  activeSong,\n  websocketConnected,\n  songsQueue\n});\n\nexport const store = createStore(\n  app,\n  initialState,\n  applyMiddleware(loggerMiddleware, thunkMiddleware)\n);\n","import { Action, Token, StandardAction } from \"../Actions/index\";\n\nexport function token(\n  state: Token = {} as Token,\n  action: StandardAction<Token>\n): Token {\n  switch (action.type) {\n    case Action.SAVE_TOKEN:\n      return action.value;\n    case Action.DELETE_TOKEN:\n      return action.value;\n    case Action.REFRESH_TOKEN:\n    default:\n      return state;\n  }\n}\n","import { Action, User, StandardAction } from \"../Actions/index\";\nexport function user(\n  state: User = {} as User,\n  action: StandardAction<User>\n): User {\n  switch (action.type) {\n    case Action.SAVE_USER_PROFILE:\n      return action.value;\n    case Action.USER_FETCH_FAILED:\n    default:\n      return state;\n  }\n}\n","import { Action, Album, StandardAction } from \"../Actions/index\";\nexport function albums(state: Album[] = [], action: StandardAction<Album[]>): Album[] {\n    switch (action.type) {\n        case Action.SAVE_ALBUMS:\n            return action.value;\n        case Action.ALBUMS_FETCH_FAILED:\n            return []\n        default:\n            return state;\n\n    }\n}\n","import { Action, Song, StandardAction } from \"../Actions/index\";\nexport function songs(\n  state: Song[] = [],\n  action: StandardAction<Song[]>\n): Song[] {\n  switch (action.type) {\n    case Action.SAVE_SONGS:\n      return action.value;\n    case Action.SONGS_FETCH_FAILED:\n      return [];\n    default:\n      return state;\n  }\n}\n","import { StandardAction, Song, Action } from \"../Actions\";\n\nexport function activeSong(\n  state: Song = {} as Song,\n  action: StandardAction<Song>\n): Song {\n  switch (action.type) {\n    case Action.SET_ACTIVE_SONG:\n      return action.value;\n    default:\n      return state;\n  }\n}\n","import { StandardAction, Action } from \"../Actions/index\";\n// websocket connection\n\nexport function websocketConnected(\n  state: boolean = false,\n  action: StandardAction<boolean>\n): boolean {\n  switch (action.type) {\n    case Action.WS_CONNECTION_FAILED:\n      return false;\n    case Action.WS_CONNECTION_SUCCESSFULL:\n      return true;\n    default:\n      return state;\n  }\n}\n","import { Action, Song, SongsQueueAction } from \"../Actions\";\n\nexport function songsQueue(\n  state: Song[] = [],\n  action: SongsQueueAction\n): Song[] {\n  switch (action.type) {\n    case Action.ADD_SONGS_TO_QUEUE:\n      return state.concat(action.songs);\n    case Action.TOGGLE_SONG_IN_QUEUE:\n      return state.map((song: Song) => {\n        if (song.name == action.songName) {\n          return {\n            ...song,\n            isReady: action.isReady\n          };\n        } else {\n          return song;\n        }\n      });\n    // this overrides whole array of songs\n    case Action.SAVE_SONGS_IN_QUEUE:\n      return action.songs;\n    case Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE:\n      if (state.length > 0) {\n        return state.slice(1, state.length);\n      } else {\n        return state;\n      }\n    default:\n      return state;\n  }\n}\n","import { Song, User, Token } from \"../Actions/index\";\nimport { ReduxState } from \"./index\";\n\nexport const initialState: ReduxState = {\n  token: <Token>{},\n  songs: [],\n  user: <User>{},\n  albums: [],\n  previousSongs: [],\n  activeSong: <Song>{},\n  websocketConnected: false,\n  songsQueue: []\n};\n","import React, { Component } from \"react\";\nimport { Song, Artist, SongReadiness } from \"../../Actions/index\";\nimport { List, Avatar, Icon } from \"antd\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\n\ninterface SongProps {\n  song: Song;\n  setActiveSong: (song: Song) => void;\n}\n\nexport function formatArtists(artists: Artist[]) {\n  return artists\n    .slice(0, 3)\n    .map(artist => artist.name)\n    .join(\", \");\n}\n\nfunction formatText(description: string) {\n  const maxNumberOfLetters = window.innerWidth / 10;\n  if (description.length > maxNumberOfLetters) {\n    return `${description.slice(0, maxNumberOfLetters)}...`;\n  } else {\n    return description;\n  }\n}\n\nexport class SongItem extends Component<SongProps> {\n  render() {\n    const { artists } = this.props.song;\n\n    return (\n      <List.Item\n        className=\"list-item-song\"\n        onClick={() => {\n          this.props.setActiveSong(this.props.song);\n        }}\n      >\n        <List.Item.Meta\n          avatar={<Avatar src={this.props.song.thumbnail_url} />}\n          title={\n            <span className=\"song-name\">\n              {formatText(this.props.song.name)}\n            </span>\n          }\n          description={formatText(artists)}\n        />\n      </List.Item>\n    );\n  }\n}\n\nexport class SongQueueItem extends Component<SongProps> {\n  render() {\n    const { artists } = this.props.song;\n    return (\n      <List.Item\n        className=\"list-item-song\"\n        onClick={() => {\n          this.props.setActiveSong(this.props.song);\n        }}\n      >\n        {formatProgress(this.props.song.isReady)}\n        <List.Item.Meta\n          avatar={<Avatar src={this.props.song.thumbnail_url} />}\n          title={\n            <span className=\"song-name\">\n              {formatText(this.props.song.name)}\n            </span>\n          }\n          description={formatText(artists)}\n        />\n      </List.Item>\n    );\n  }\n}\n\nconst progress = css({\n  fontSize: 24\n});\n\nconst failed = css({\n  color: \"#ba252f\"\n});\n\nconst success = css({\n  color: \"#15c455\"\n});\n\nfunction formatProgress(readiness: SongReadiness) {\n  switch (readiness) {\n    case SongReadiness.CANT_DOWNLOAD:\n      return (\n        <Icon\n          title=\"Song can't be downloaded\"\n          type=\"close-circle\"\n          css={[progress, failed]}\n        />\n      );\n    case SongReadiness.NOT_READY:\n      return (\n        <Icon title=\"Downloading song\" type=\"loading\" css={progress} spin />\n      );\n    case SongReadiness.READY:\n      return (\n        <Icon\n          type=\"check-circle\"\n          title=\"Song successfully downloaded\"\n          css={[progress, success]}\n        />\n      );\n  }\n}\n","import React, { Component } from \"react\";\nimport { Song, setActiveSong } from \"../../Actions/index\";\nimport { SongItem } from \"../Presentational/index\";\nimport { connect } from \"react-redux\";\nimport { ReduxState } from \"../../Stores/index\";\nimport { List, Menu, Input, notification } from \"antd\";\nimport { Dispatch } from \"redux\";\nimport { addSongsToQueue } from \"../../Actions/songsQueue\";\nimport { SongQueueItem } from \"../Presentational/Song\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\nimport { scheduleSong } from \"../../Actions/activeSong\";\n\nconst Search = Input.Search;\ntype SongListProps = {\n  songs: Song[];\n  songsQueue: Song[];\n  setActiveSong: (song: Song) => void;\n};\n\nenum SelectedList {\n  YourSongs = \"YourSongs\",\n  SongsQueue = \"SongsQueue\"\n}\n\ntype SongListState = {\n  offset: number;\n  currentPage: number;\n  window_height: number;\n  window_width: number;\n  selectedList: SelectedList;\n  searchbarValue: string;\n  indexesToFade: number[];\n};\n\nclass SongList extends Component<SongListProps, SongListState> {\n  state = {\n    offset: 0,\n    currentPage: 1,\n    window_height: window.innerHeight,\n    window_width: window.innerWidth,\n    selectedList: SelectedList.YourSongs,\n    searchbarValue: \"\",\n    indexesToFade: []\n  };\n\n  getData = (songs: Song[]) => {\n    if (this.state.searchbarValue.length === 0) {\n      return songs;\n    }\n    return songs.filter(song => {\n      const songName = song.name.toLowerCase();\n      const artists = song.artists.toLowerCase();\n      return (\n        songName.includes(this.state.searchbarValue) ||\n        artists.includes(this.state.searchbarValue)\n      );\n    });\n  };\n\n  handleTransition = (songs: Song[]) => {\n    return songs;\n  };\n\n  render() {\n    const songs =\n      this.state.selectedList === SelectedList.SongsQueue\n        ? this.getData(this.props.songsQueue)\n        : this.getData(this.props.songs);\n    return (\n      <div className=\"list-container\">\n        <Menu\n          onClick={e => {\n            const key =\n              e.key === \"YourSongs\"\n                ? SelectedList.YourSongs\n                : SelectedList.SongsQueue;\n            this.setState({ selectedList: key });\n          }}\n          selectedKeys={[this.state.selectedList]}\n          mode=\"horizontal\"\n        >\n          <Menu.Item key={SelectedList.YourSongs}>Your songs</Menu.Item>\n          <Menu.Item key={SelectedList.SongsQueue}>Songs queue</Menu.Item>\n        </Menu>\n        <Search\n          placeholder=\"filter songs...\"\n          size=\"default\"\n          name=\"domains\"\n          value={this.state.searchbarValue}\n          onChange={(e: any) => {\n            const { value } = e.target;\n            this.setState({ searchbarValue: value });\n          }}\n          onSearch={(name: string) => {\n            if (name.length == 0) {\n              return;\n            }\n          }}\n        />\n        <span>\n          <List\n            locale={{\n              emptyText:\n                this.state.selectedList === SelectedList.SongsQueue\n                  ? \"There are no songs scheduled in the queue\"\n                  : \"There are no favourite songs in your spotify account.\"\n            }}\n            bordered={false}\n            size={\"large\"}\n            itemLayout=\"horizontal\"\n            dataSource={songs}\n            renderItem={(song: Song) => {\n              if (this.state.selectedList === SelectedList.SongsQueue) {\n                return (\n                  <SongQueueItem\n                    setActiveSong={this.props.setActiveSong}\n                    song={song}\n                  />\n                );\n              } else {\n                return (\n                  <SongItem\n                    setActiveSong={this.props.setActiveSong}\n                    song={song}\n                  />\n                );\n              }\n            }}\n            pagination={{\n              total: songs.length,\n              pageSize: window.innerHeight / 110,\n              simple: true,\n              showQuickJumper: true\n            }}\n          />\n        </span>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    songs: state.songs,\n    songsQueue: state.songsQueue\n  };\n};\n\nconst dispatchToProps = (dispatch: Dispatch) => {\n  return {\n    setActiveSong: (song: Song) => {\n      // set song to be active, true indicates that we want to download it\n      notification.success({\n        description: song.formatted_name,\n        message: \"Successfully scheduled\",\n        duration: window.innerWidth >= 576 ? 2 : 1\n      });\n      scheduleSong(song);\n      dispatch(addSongsToQueue([song]));\n    }\n  };\n};\n\nconst SongListComponent = connect(\n  mapStateToProps,\n  dispatchToProps\n)(SongList);\n\nexport { SongListComponent as SongList };\n","/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\nimport React, { Component } from \"react\";\nimport { Song, isObjectEmpty } from \"../../Actions/index\";\nimport { Avatar, Slider } from \"antd\";\nimport { Dispatch } from \"redux\";\nimport { ReduxState } from \"../../Stores\";\nimport { connect } from \"react-redux\";\ntype MusicPlayerProps = {\n  previousSongs: Song[];\n  activeSong: Song;\n  nextSong: () => void;\n  previousSong: () => void;\n};\n\nfunction convertTime(time: number) {\n  const seconds = Math.floor(time);\n  const mins = Math.floor(seconds / 60);\n  const secondsRemaining = seconds - mins * 60;\n\n  // if seconds are less than 10 add 0 at the begining of the string so it looks like 0:01\n  return `${mins}:${\n    secondsRemaining < 10 ? `0${secondsRemaining}` : secondsRemaining\n  }`;\n}\n\nconst breakpoint = `@media (max-width: 576px)`;\n\nconst musicPlayer = css({\n  background: \"#282828\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"flex-end\",\n  width: \"100%\",\n  marginLeft: \"auto\",\n  marginRight: \"auto\",\n  flexWrap: \"wrap\",\n  padding: \"1rem 5% 1rem 5%\",\n  height: \"8rem\"\n  // [breakpoint]: {\n  //   padding: \"1rem 5% 1rem 5%\"\n  // }\n});\n\nconst playerTools = css({\n  width: \"100%\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"flex-end\"\n});\n\nclass MusicPlayer extends Component<MusicPlayerProps> {\n  state = {\n    progress: 0,\n    clicked: false\n  };\n\n  render() {\n    // const { duration_ms } = this.props.activeSong;\n    const isSongSet = !isObjectEmpty(this.props.activeSong);\n    return (\n      <div css={musicPlayer}>\n        {isSongSet && <ActiveSong activeSong={this.props.activeSong} />}\n        {isSongSet && <SongTimer duration={this.props.activeSong.duration} />}\n      </div>\n    );\n  }\n}\n\ntype SongTimerProps = {\n  duration: number;\n};\n\nconst songTimer = css({\n  width: \"30%\",\n  height: \"80%\"\n});\n\nclass SongTimer extends Component<SongTimerProps> {\n  state = {\n    progress: 0\n  };\n\n  constructor(props: any) {\n    super(props);\n    setInterval(\n      () => this.setState({ progress: this.state.progress + 1 }),\n      1000\n    );\n  }\n\n  componentWillReceiveProps(props: SongTimerProps) {\n    if (props.duration !== this.props.duration) {\n      this.setState({ progress: 0 });\n    }\n  }\n\n  render() {\n    const { duration } = this.props;\n    return (\n      <div css={songTimer}>\n        <div>\n          {convertTime(this.state.progress)} / {convertTime(duration)}\n        </div>\n      </div>\n    );\n  }\n}\n\ntype ActiveSongProps = {\n  activeSong: Song;\n};\n\nconst activeSong = css({\n  width: \"70%\",\n  height: \"80%\",\n  [breakpoint]: {\n    width: \"70%\"\n  }\n});\n\nclass ActiveSong extends Component<ActiveSongProps> {\n  render() {\n    return (\n      <div css={activeSong}>\n        <Avatar\n          size={50}\n          shape={\"square\"}\n          src={this.props.activeSong.thumbnail_url}\n        />\n        <div style={{ display: \"inline-block\", paddingLeft: \"0.5rem\" }}>\n          <div style={{ fontSize: \"0.9rem\", width: \"100%\" }}>\n            {this.props.activeSong.name}\n          </div>\n          <div style={{ fontSize: \"0.7rem\", width: \"100%\", color: \"#b3b3b3\" }}>\n            {this.props.activeSong.artists}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n// Music player's dispatch to props and state to props\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    songs: state.songs,\n    previousSongs: state.previousSongs,\n    activeSong: state.activeSong\n  };\n};\n\nconst dispatchToProps = (dispatch: Dispatch) => {\n  return {\n    // set some random song to be active and save it in previousSongs history\n    nextSong: () => {\n      // dispatch(setRandomSong(true));\n    },\n    // set last element of previousSongs array to be active song then pop it off\n    // if there are no elements in the previousSongs array a random song will be set to be active\n    previousSong: () => {\n      //dispatch(setPreviousSong());\n    }\n  };\n};\n\nexport const MusicPlayerComponent = connect(\n  mapStateToProps,\n  dispatchToProps\n)(MusicPlayer);\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport {\n  Login,\n  AuthRedirection as AuthRedirectionComponent\n} from \"./Components/index\";\nimport { Provider, connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\nimport { store, ReduxState } from \"./Stores/index\";\nimport {\n  saveToken,\n  getUserFavouriteSongs,\n  Token,\n  TokenStatus,\n  SongsState,\n  getTokenFromLocalStorage,\n  getUserAlbums,\n  getUserInformations\n} from \"./Actions/index\";\nimport { RouteComponentProps } from \"react-router-dom\";\nimport { SongList, MusicPlayer } from \"./Components/Containers/index\";\n\ninterface AppProps extends RouteComponentProps {\n  fetchUserInformations: () => void;\n  fetchUserAlbums: () => void;\n  fetchAlbumSongs: () => void;\n  fetchFavouriteSongs: () => void;\n  getTokenFromLocalStorage: () => void;\n  token: Token;\n  socketConnected: boolean;\n}\n\nclass App extends Component<AppProps> {\n  state = {\n    didRouteChange: false\n  };\n\n  componentDidMount() {\n    this.props.getTokenFromLocalStorage();\n  }\n\n  componentWillReceiveProps(props: AppProps) {\n    // didRouteChange is used to prevent infinite loops of props updates caused due to changed props of react-router\n    // if token got from local storage is expired redirect to login component\n    if (\n      props.token.status === TokenStatus.EXPIRED &&\n      !this.state.didRouteChange\n    ) {\n      this.props.history.push(\"/login\");\n      this.setState({ didRouteChange: true });\n    }\n    // if token got from local storage is not expired fetch needed data and redirect to component that lists songs\n    else if (\n      props.token.value.length > 0 &&\n      !this.state.didRouteChange &&\n      props.token.status !== TokenStatus.EXPIRED\n    ) {\n      this.props.fetchUserInformations();\n      this.props.fetchUserAlbums();\n      this.props.fetchFavouriteSongs();\n      this.props.history.push(\"/songs\");\n      this.setState({ didRouteChange: true });\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App-header\">\n        <Switch>\n          <Route path=\"/auth\" component={AuthRedirection} />\n          <Route path=\"/songs\" component={SongList} />\n          <Route path=\"/\" component={Login} />\n        </Switch>\n        {this.props.socketConnected && <MusicPlayer />}\n      </div>\n    );\n  }\n}\n\nclass Root extends Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <Router>\n          <Route path=\"/\" component={AppCore} />\n        </Router>\n      </Provider>\n    );\n  }\n}\n\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    token: state.token,\n    socketConnected: state.websocketConnected\n  };\n};\n\n// DTP - dispatch to props\nconst appDTP = (dispatch: Dispatch) => {\n  return {\n    fetchUserInformations: async () => {\n      dispatch(await getUserInformations());\n    },\n    fetchUserAlbums: async () => {\n      dispatch(await getUserAlbums());\n    },\n    fetchFavouriteSongs: async () => {\n      await getUserFavouriteSongs(dispatch);\n    },\n    getTokenFromLocalStorage: () => {\n      dispatch(getTokenFromLocalStorage());\n    }\n  };\n};\n\nconst AppCore = connect(\n  mapStateToProps,\n  appDTP\n)(App);\n\n// DTP - dispatch to props\n\nconst authRedirectionDTP = (dispatch: Dispatch) => {\n  return {\n    saveToken: (token: string) => {\n      dispatch(saveToken(token));\n    }\n  };\n};\n\nconst AuthRedirection = connect(\n  mapStateToProps,\n  authRedirectionDTP\n)(AuthRedirectionComponent);\n\nexport default Root;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Root from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { notification } from \"antd\";\nnotification.config({\n  placement: \"bottomRight\",\n  bottom: -5\n});\nReactDOM.render(<Root />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}