{"version":3,"sources":["Components/Login.tsx","Actions/auth.ts","Functions/requests.ts","Actions/albums.ts","Actions/songs.ts","Actions/songsQueue.ts","Actions/websocket.ts","Actions/index.ts","Actions/activeSong.ts","Actions/functions.ts","Actions/user.ts","Stores/store.ts","Reducers/auth.ts","Reducers/user.ts","Reducers/albums.ts","Reducers/songs.ts","Reducers/songsState.ts","Reducers/websocket.ts","Reducers/songsQueue.ts","Stores/initialState.ts","Components/Presentational/Song.tsx","Components/Containers/SongList.tsx","Components/Containers/MusicPlayer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["linkContainer","css","height","background","display","justifyContent","alignItems","width","link","fontSize","Login","_Component","_getPrototypeOf2","_this","Object","classCallCheck","this","_len","arguments","length","args","Array","_key","possibleConstructorReturn","getPrototypeOf","call","apply","concat","clientId","responseType","redirectURL","linkToSpotifyAuth","inherits","createClass","key","value","core_browser_esm","href","className","Component","AuthRedirection","_Component2","_getPrototypeOf3","_this2","_len3","_key3","getToken","props","token","undefined","location","hash","split","saveToken","convertToken","status","createdAt","moment","expiresAt","axios","defaults","baseURL","saveUserAlbums","albums","type","Action","SAVE_ALBUMS","fetchUserAlbums","Actions_albums_fetchUserAlbums","_callee","regenerator_default","a","wrap","_context","prev","next","store","getState","get","headers","Authorization","then","response","data","items","error","catch","e","sent","abrupt","stop","getUserAlbums","_getUserAlbums","_callee2","_context2","ALBUMS_FETCH_FAILED","saveSongs","songs","SAVE_SONGS","fetchUserSongs","_x","_fetchUserSongs","paginationStatus","total","offset","map","item","name","artists","track","id","thumbnail_url","album","images","url","duration","formatted_name","artist","join","isReady","SongReadiness","NOT_READY","getUserFavouriteSongs","_x2","_getUserFavouriteSongs","dispatch","songsChunk","firstFetch","SONGS_FETCH_FAILED","toggleSong","songName","TOGGLE_SONG_IN_QUEUE","ws","WebSocket","setSocketError","WS_CONNECTION_FAILED","TokenStatus","setActiveSong","song","SET_ACTIVE_SONG","scheduleSong","thumbnailUrl","action","payload","send","JSON","stringify","sendSong","isObjectEmpty","obj","entries","constructor","saveUserData","user","SAVE_USER_PROFILE","getUserInformations","_getUserInformations","fetchUserInformations","display_name","USER_FETCH_FAILED","Actions_user_fetchUserInformations","onopen","event","notification","success","message","description","WS_CONNECTION_SUCCESSFULL","onclose","onerror","onmessage","parse","console","log","open","next_song","DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE","queue","songs_queue","SAVE_SONGS_IN_QUEUE","activeSong","active_song","downloadedSong","READY","failedSong","CANT_DOWNLOAD","loggerMiddleware","createLogger","app","combineReducers","state","SAVE_TOKEN","DELETE_TOKEN","REFRESH_TOKEN","websocketConnected","songsQueue","ADD_SONGS_TO_QUEUE","objectSpread","slice","createStore","previousSongs","applyMiddleware","thunkMiddleware","formatText","maxNumberOfLetters","window","innerWidth","SongItem","list","Item","onClick","Meta","avatar","src","title","SongQueueItem","readiness","icon","progress","failed","spin","formatProgress","color","SelectedList","Search","Input","SongList","currentPage","window_height","innerHeight","window_width","selectedList","YourSongs","searchbarValue","indexesToFade","getData","filter","toLowerCase","includes","handleTransition","SongsQueue","menu","setState","selectedKeys","mode","placeholder","size","onChange","target","onSearch","locale","emptyText","bordered","itemLayout","dataSource","renderItem","Song_SongQueueItem","Song_SongItem","pagination","pageSize","simple","showQuickJumper","SongListComponent","connect","convertTime","time","seconds","Math","floor","mins","secondsRemaining","musicPlayer","marginLeft","marginRight","flexWrap","padding","MusicPlayer","clicked","isSongSet","MusicPlayer_ActiveSong","MusicPlayer_SongTimer","songTimer","SongTimer","setInterval","defineProperty","ActiveSong","shape","style","paddingLeft","MusicPlayerComponent","nextSong","previousSong","App","didRouteChange","getTokenFromLocalStorage","EXPIRED","fetchFavouriteSongs","history","push","react_default","createElement","Switch","Route","path","component","socketConnected","Root","es","BrowserRouter","AppCore","mapStateToProps","_fetchUserInformations","asyncToGenerator","mark","t0","t1","_fetchUserAlbums","_fetchFavouriteSongs","_callee3","_context3","isBefore","tokenToSave","OK","add","AuthRedirectionComponent","Boolean","hostname","match","config","placement","bottom","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c496546e.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { RouteComponentProps } from \"react-router-dom\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\n\ninterface AuthProps extends RouteComponentProps {\n  saveToken: (token: string) => void;\n}\n\nconst linkContainer = css({\n  height: \"87vh\",\n  background: \"#282828\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  width: \"100%\"\n});\n\nconst link = css({\n  fontSize: \"2rem\"\n});\n\nexport class Login extends Component<AuthProps> {\n  clientId = \"d09edd82dac149a5b6f076515368e06d\";\n  responseType = \"token\";\n  redirectURL = \"http://localhost:3000/auth\";\n  linkToSpotifyAuth = `https://accounts.spotify.com/authorize?client_id=${\n    this.clientId\n  }&redirect_uri=${this.redirectURL}&response_type=${\n    this.responseType\n  }&scope=user-library-read`;\n\n  render() {\n    return (\n      <div css={linkContainer}>\n        <a css={link} href={this.linkToSpotifyAuth} className=\"App-link\">\n          Login to spotify\n        </a>\n      </div>\n    );\n  }\n}\n\nexport class AuthRedirection extends Component<AuthProps> {\n  componentDidMount() {\n    this.getToken(this.props);\n  }\n  getToken = (props: AuthProps) => {\n    // get token from hash after redirection from spotify login page, after splitting it by = split it by & to remove next query parameter from it\n    const queryParams =\n      props.location.hash === undefined ? \"\" : props.location.hash;\n    const rawToken = queryParams.split(\"=\")[1] || \"\";\n    // token to return\n    const token = rawToken.split(\"&\")[0] || \"\";\n    // save token to global store\n    this.props.saveToken(token);\n  };\n\n  render() {\n    return <div>Authenticated</div>;\n  }\n}\n","import { Action, Token, StandardAction, TokenStatus, TokenFromLocalStorage } from \"./index\";\nimport * as store from \"store\";\nimport moment from \"moment\";\nimport { isObjectEmpty } from \"./index\";\n\nfunction convertToken(token: TokenFromLocalStorage): Token {\n    return {\n        value: token.value,\n        status: token.status,\n        createdAt: moment(token.createdAt),\n        expiresAt: moment(token.expiresAt),\n    }\n}\n\nexport function getTokenFromLocalStorage(): StandardAction<Token> {\n    const token: TokenFromLocalStorage = store.get(\"token\", {});\n    if (moment(token.expiresAt).isBefore(moment()) || isObjectEmpty(token)) {\n        return {\n            value: {\n                value: \"EXPIRED_TOKEN\",\n                status: TokenStatus.EXPIRED,\n                createdAt: moment(),\n                expiresAt: moment()\n            },\n            type: Action.SAVE_TOKEN\n        }\n    }\n    return {\n        value: convertToken(token),\n        type: Action.SAVE_TOKEN\n    }\n}\n\nexport function saveToken(token: string): StandardAction<Token> {\n    const tokenToSave: Token = {\n        value: token,\n        status: TokenStatus.OK,\n        createdAt: moment(),\n        expiresAt: moment().add(3600, \"seconds\")\n    };\n    // save token in local storage\n    store.set(\"token\", tokenToSave);\n    return {\n        value: tokenToSave,\n        type: Action.SAVE_TOKEN\n    }\n}\n\n\nexport function deleteToken(): StandardAction<Token> {\n    return {\n        value: {} as Token,\n        type: Action.DELETE_TOKEN\n    }\n}","import axios from \"axios\";\naxios.defaults.baseURL = \"https://api.spotify.com/v1\";\nexport default axios;\n","import { Album, StandardAction, Action, RequestData } from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\n\nexport function saveUserAlbums(albums: Album[]): StandardAction<Album[]> {\n    return {\n        value: albums,\n        type: Action.SAVE_ALBUMS\n    }\n}\n\nexport function albumsFetchFailed(): StandardAction<Album[]> {\n    return {\n        value: [],\n        type: Action.ALBUMS_FETCH_FAILED\n    }\n}\n\n\nexport async function fetchUserAlbums() {\n    const token = store.getState().token.value;\n    const albums = await axios.get<RequestData<Album>>(\"/me/playlists\", {\n        headers: {\n            'Authorization': `Bearer  ${token}`\n        }\n    }).then((response) => {\n        const { data } = response;\n        return { value: data.items, error: false } as Result<Album[]>;\n    }).catch(e => { return { error: true } as Result<Album[]> });\n    return albums;\n}\n\nexport async function getUserAlbums() {\n    const albums = await fetchUserAlbums();\n    if (albums.error) {\n        return albumsFetchFailed();\n    } else {\n        return saveUserAlbums(albums.value);\n    }\n}\n\n","import {\n  Album,\n  StandardAction,\n  Action,\n  Song,\n  SongsRequestData,\n  Artist,\n  SongReadiness,\n  PlainSong\n} from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\nimport { Dispatch } from \"react\";\nimport { AnyAction } from \"redux\";\n\nexport function saveSongs(songs: Song[]): StandardAction<Song[]> {\n  return {\n    value: songs,\n    type: Action.SAVE_SONGS\n  };\n}\n\nexport function songsFetchFailed(): StandardAction<Album[]> {\n  return {\n    value: [],\n    type: Action.SONGS_FETCH_FAILED\n  };\n}\n\ntype PaginationStatus = {\n  // total number of songs available\n  total: number;\n  // number of songs already downloaded\n  offset: number;\n  firstFetch: boolean;\n};\n\nfunction formatName(name: string, artists: Artist[]) {\n  return `${name} - ${artists.map(artist => artist.name).join(\", \")}`;\n}\n\nexport async function fetchUserSongs(paginationStatus: PaginationStatus) {\n  const token = store.getState().token.value;\n\n  // total number of songs\n  let total = 0;\n  const songs = await axios\n    .get<SongsRequestData>(\n      `/me/tracks?limit=50&offset=${paginationStatus.offset}`,\n      {\n        headers: {\n          Authorization: `Bearer  ${token}`\n        }\n      }\n    )\n    .then(response => {\n      const { data } = response;\n      total = data.total;\n      // unwrap songs from song containers\n      const songs: Song[] = data.items.map(item => {\n        const { track } = item;\n        return {\n          id: track.id,\n          name: track.name,\n          thumbnail_url: track.album.images[0].url,\n          duration: track.duration / 1000,\n          formatted_name: formatName(track.name, track.artists),\n          isReady: SongReadiness.NOT_READY,\n          artists: track.artists.map(artist => artist.name).join(\", \")\n        };\n      });\n      return { value: songs, error: false } as Result<Song[]>;\n    })\n    .catch(e => {\n      return { error: true } as Result<Song[]>;\n    });\n\n  // calculate next offset based on the previous ones and number of songs that we just fetched\n  return { songs, total, offset: paginationStatus.offset + songs.value.length };\n}\n\nexport async function getUserFavouriteSongs(dispatch: Dispatch<AnyAction>) {\n  let paginationStatus: PaginationStatus = {\n    total: 0,\n    offset: 0,\n    firstFetch: true\n  };\n  let songs: Song[] = [];\n\n  // fetch songs until all of\n  while (\n    paginationStatus.offset < paginationStatus.total ||\n    paginationStatus.firstFetch\n  ) {\n    // fetch next chunk of songs, function might only download 50 songs at once\n    const songsChunk = await fetchUserSongs(paginationStatus);\n    // throw an error action in case of errors\n    if (songsChunk.songs.error) {\n      dispatch(songsFetchFailed());\n    } else {\n      // set new pagination status with new offset which is an index from where next function will start fetching new songs\n      paginationStatus = {\n        offset: songsChunk.offset,\n        total: songsChunk.total,\n        firstFetch: false\n      };\n      songs = songs.concat(songsChunk.songs.value);\n      dispatch(saveSongs(songs));\n    }\n  }\n}\n","import { Action, Song, SongsQueueAction, SongReadiness } from \".\";\n\nexport function getSongsQueue() {}\n\nexport function addSongsToQueue(songs: Song[]): SongsQueueAction {\n  return {\n    type: Action.ADD_SONGS_TO_QUEUE,\n    songs\n  };\n}\n\nexport function saveSongsInQueue(songs: Song[]): SongsQueueAction {\n  return {\n    type: Action.SAVE_SONGS_IN_QUEUE,\n    songs\n  };\n}\n\nexport function deleteRecentActiveSongFromQueue(): SongsQueueAction {\n  return {\n    type: Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE\n  };\n}\n\n// toggle song\nexport function toggleSong(\n  songName: string,\n  isReady: SongReadiness\n): SongsQueueAction {\n  return {\n    type: Action.TOGGLE_SONG_IN_QUEUE,\n    isReady,\n    songName\n  };\n}\n","import { StandardAction, Action, Song, SongReadiness } from \"./index\";\nimport { store } from \"../Stores/index\";\nimport { setActiveSong } from \"./activeSong\";\nimport {\n  toggleSong,\n  saveSongsInQueue,\n  deleteRecentActiveSongFromQueue\n} from \"./songsQueue\";\nimport { notification } from \"antd\";\nexport const ws = new WebSocket(\"ws://127.0.0.1:8080/ws/\");\n\ntype WSAction = {\n  action: string;\n  success: boolean;\n  value: any;\n};\n\ntype NextSong = {\n  name: string;\n  duration: number;\n  path: string;\n};\n\nfunction setSocketConnected(): StandardAction<boolean> {\n  return {\n    type: Action.WS_CONNECTION_SUCCESSFULL,\n    value: true\n  };\n}\n\nfunction setSocketError(): StandardAction<boolean> {\n  return {\n    type: Action.WS_CONNECTION_FAILED,\n    value: false\n  };\n}\n\nlet isSocketOpened = false;\n\nws.onopen = event => {\n  isSocketOpened = true;\n  notification.success({\n    message: \"Connection\",\n    description: \"Successfully connected to the home-fm-server.\"\n  });\n  store.dispatch(setSocketConnected());\n};\n\nws.onclose = event => {\n  isSocketOpened = false;\n  notification.error({\n    message: \"Connection\",\n    description: \"Diconnected from home-fm-server\"\n  });\n  store.dispatch(setSocketError());\n};\n\nws.onerror = event => {\n  notification.error({\n    message: \"Connection\",\n    duration: 10,\n    description: \"home-fm-server isn't turned on\"\n  });\n  store.dispatch(setSocketError());\n};\n\nws.onmessage = event => {\n  const data: WSAction = JSON.parse(event.data);\n  switch (data.action) {\n    case \"next_song\":\n      console.log(data.value);\n      notification.open({\n        message: \"Now playing\",\n        description: `${data.value.next_song.name} - ${\n          data.value.next_song.artists\n        }`\n      });\n      handleNextSong(data.value.next_song as Song);\n      store.dispatch(deleteRecentActiveSongFromQueue());\n      break;\n    case \"queue_state\":\n      const queue: Song[] = data.value.songs_queue;\n      store.dispatch(saveSongsInQueue(queue));\n      let activeSong: Song = data.value.active_song;\n      store.dispatch(setActiveSong(activeSong));\n      return;\n    case \"song_download_finished\":\n      let downloadedSong: Song = data.value;\n      store.dispatch(toggleSong(downloadedSong.name, SongReadiness.READY));\n      return;\n    case \"song_download_failed\":\n      let failedSong: Song = data.value;\n      store.dispatch(toggleSong(failedSong.name, SongReadiness.CANT_DOWNLOAD));\n      return;\n    case \"song_download_started\":\n      break;\n    default:\n  }\n};\n\nfunction handleNextSong(song: Song) {\n  store.dispatch(setActiveSong(song));\n}\n\nexport function sendSong(\n  songName: string,\n  artists: string,\n  thumbnailUrl: string\n) {\n  const data = {\n    action: \"request_song\",\n    payload: {\n      artists,\n      name: songName,\n      thumbnail_url: thumbnailUrl\n    }\n  };\n  ws.send(JSON.stringify(data));\n}\n\nfunction convertSongs(songs: Song[]) {}\n","import { Moment } from \"moment\";\n\nexport { saveToken, deleteToken, getTokenFromLocalStorage } from \"./auth\";\nexport { fetchUserAlbums, getUserAlbums } from \"./albums\";\nexport { getUserFavouriteSongs } from \"./songs\";\nexport { setActiveSong } from \"./activeSong\";\nexport { randomNumber, isObjectEmpty } from \"./functions\";\nexport { getUserInformations } from \"./user\";\nexport { ws } from \"./websocket\";\nexport type Token = {\n  value: string;\n  status: TokenStatus;\n  createdAt: Moment;\n  expiresAt: Moment;\n};\n\nexport type TokenFromLocalStorage = {\n  value: string;\n  status: TokenStatus;\n  createdAt: Date;\n  expiresAt: Date;\n};\n\nexport type User = {\n  display_name: string;\n};\n\nexport type StandardAction<T> = {\n  value: T;\n  type: Action;\n};\n\nexport type AddSongs = {\n  type: Action.ADD_SONGS_TO_QUEUE;\n  songs: Song[];\n};\n\nexport type ToggleSong = {\n  type: Action.TOGGLE_SONG_IN_QUEUE;\n  isReady: SongReadiness;\n  songName: string;\n};\n\nexport type SaveSongs = {\n  type: Action.SAVE_SONGS_IN_QUEUE;\n  songs: Song[];\n};\n\nexport type DeleteRecentActiveSong = {\n  type: Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE;\n};\n\nexport type SongsQueueAction =\n  | SaveSongs\n  | AddSongs\n  | ToggleSong\n  | DeleteRecentActiveSong;\n\nexport enum Action {\n  // token actions\n  SAVE_TOKEN,\n  DELETE_TOKEN,\n  REFRESH_TOKEN,\n  // user actions\n  SAVE_USER_PROFILE,\n  USER_FETCH_FAILED,\n  // albums actions\n  SAVE_ALBUMS,\n  ALBUMS_FETCH_FAILED,\n  // songs actions\n  SAVE_SONGS,\n  SONGS_FETCH_FAILED,\n  // activeSong actions\n  SET_ACTIVE_SONG,\n  // previous songs\n  PUSH_SONG,\n  POP_SONG,\n  // websocket actions\n  WS_CONNECTION_FAILED,\n  WS_CONNECTION_SUCCESSFULL,\n  // songs state\n  SAVE_SONGS_IN_QUEUE,\n  ADD_SONGS_TO_QUEUE,\n  TOGGLE_SONG_IN_QUEUE,\n  DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE\n}\n\nexport enum TokenStatus {\n  OK,\n  INVALID,\n  EXPIRED\n}\n\nexport type Album = {\n  name: string;\n  id: string;\n  images: Image[];\n  tracks: Tracks;\n};\n\n// request data type to unpack items from axios requests\nexport type RequestData<T> = {\n  items: T[];\n};\n\nexport type SongContainer = {\n  created_at: Date;\n  track: PlainSong;\n};\n\nexport interface SongsRequestData extends RequestData<SongContainer> {\n  // total number of songs user added to his library, used for pagination\n  total: number;\n}\n\n// object containing informations about api to fetch albums songs\nexport type Tracks = {\n  href: string;\n  total: number;\n};\n\nexport type Image = {\n  url: string;\n};\n\n// plain song object from spotify api\nexport type PlainSong = {\n  href: string;\n  name: string;\n  artists: Artist[];\n  album: Album;\n  id: string;\n  duration: number;\n  formatted_name: string;\n  // it's gonna be used in queue to determine whether server downloaded it already or not\n  isReady: SongReadiness;\n};\n\nexport type Song = {\n  name: string;\n  artists: string;\n  id: string;\n  duration: number;\n  formatted_name: string;\n  thumbnail_url: string;\n  // it's gonna be used in queue to determine whether server downloaded it already or not\n  isReady: SongReadiness;\n};\n\nexport enum SongReadiness {\n  READY,\n  NOT_READY,\n  CANT_DOWNLOAD\n}\n\nexport type Artist = {\n  name: string;\n};\n\nexport type SongsState = {\n  activeSong: Song;\n  previousSongs: Song[];\n};\n","import { Action, Song, StandardAction, randomNumber } from \"./index\";\nimport { sendSong } from \"./websocket\";\n\n// if pushToHistory equals true then song will be pushed to previousSongs array\nexport function setActiveSong(song: Song): StandardAction<Song> {\n  // whether we want to notify server about incoming song or not\n  return {\n    value: song,\n    type: Action.SET_ACTIVE_SONG\n  };\n}\n\nexport function scheduleSong(song: Song) {\n  sendSong(song.name, song.artists, song.thumbnail_url);\n}\n","// returns a number between min and max range\nexport function randomNumber(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nexport function isObjectEmpty(obj: any) {\n  if (obj === null) {\n    return true;\n  }\n  return Object.entries(obj).length === 0 && obj.constructor === Object;\n}\n","import { Action, User, StandardAction } from \"./index\";\nimport { Result, axios } from \"../Functions/index\";\nimport { store } from \"../Stores/index\";\n\nexport function saveUserData(user: User): StandardAction<User> {\n  return {\n    value: user,\n    type: Action.SAVE_USER_PROFILE\n  };\n}\n\nexport function userFetchFailed(): StandardAction<User> {\n  return {\n    value: { display_name: \"\" },\n    type: Action.USER_FETCH_FAILED\n  };\n}\n\nexport async function getUserInformations(): Promise<StandardAction<User>> {\n  const user = await fetchUserInformations();\n  if (user.error) {\n    return userFetchFailed();\n  } else {\n    return saveUserData(user.value);\n  }\n}\n\nexport async function fetchUserInformations() {\n  const token = store.getState().token.value;\n  const user = await axios\n    .get<User>(\"/me\", {\n      headers: {\n        Authorization: `Bearer  ${token}`\n      }\n    })\n    .then(response => {\n      const { data } = response;\n      return { value: data, error: false } as Result<User>;\n    })\n    .catch(e => {\n      return { error: true } as Result<User>;\n    });\n  return user;\n}\n","import { createStore, combineReducers, applyMiddleware } from \"redux\";\nimport {\n  token,\n  user,\n  albums,\n  songs,\n  activeSong,\n  websocketConnected,\n  songsQueue\n} from \"../Reducers/index\";\nimport { initialState } from \"./index\";\nimport thunkMiddleware from \"redux-thunk\";\nimport { createLogger } from \"redux-logger\";\n\nconst loggerMiddleware = createLogger();\n\nconst app = combineReducers({\n  token,\n  user,\n  albums,\n  songs,\n  activeSong,\n  websocketConnected,\n  songsQueue\n});\n\nexport const store = createStore(\n  app,\n  initialState,\n  applyMiddleware(loggerMiddleware, thunkMiddleware)\n);\n","import { Action, Token, StandardAction } from \"../Actions/index\";\n\nexport function token(\n  state: Token = {} as Token,\n  action: StandardAction<Token>\n): Token {\n  switch (action.type) {\n    case Action.SAVE_TOKEN:\n      return action.value;\n    case Action.DELETE_TOKEN:\n      return action.value;\n    case Action.REFRESH_TOKEN:\n    default:\n      return state;\n  }\n}\n","import { Action, User, StandardAction } from \"../Actions/index\";\nexport function user(\n  state: User = {} as User,\n  action: StandardAction<User>\n): User {\n  switch (action.type) {\n    case Action.SAVE_USER_PROFILE:\n      return action.value;\n    case Action.USER_FETCH_FAILED:\n    default:\n      return state;\n  }\n}\n","import { Action, Album, StandardAction } from \"../Actions/index\";\nexport function albums(state: Album[] = [], action: StandardAction<Album[]>): Album[] {\n    switch (action.type) {\n        case Action.SAVE_ALBUMS:\n            return action.value;\n        case Action.ALBUMS_FETCH_FAILED:\n            return []\n        default:\n            return state;\n\n    }\n}\n","import { Action, Song, StandardAction } from \"../Actions/index\";\nexport function songs(\n  state: Song[] = [],\n  action: StandardAction<Song[]>\n): Song[] {\n  switch (action.type) {\n    case Action.SAVE_SONGS:\n      return action.value;\n    case Action.SONGS_FETCH_FAILED:\n      return [];\n    default:\n      return state;\n  }\n}\n","import { StandardAction, Song, Action } from \"../Actions\";\n\nexport function activeSong(\n  state: Song = {} as Song,\n  action: StandardAction<Song>\n): Song {\n  switch (action.type) {\n    case Action.SET_ACTIVE_SONG:\n      return action.value;\n    default:\n      return state;\n  }\n}\n","import { StandardAction, Action } from \"../Actions/index\";\n// websocket connection\n\nexport function websocketConnected(\n  state: boolean = false,\n  action: StandardAction<boolean>\n): boolean {\n  switch (action.type) {\n    case Action.WS_CONNECTION_FAILED:\n      return false;\n    case Action.WS_CONNECTION_SUCCESSFULL:\n      return true;\n    default:\n      return state;\n  }\n}\n","import { Action, Song, SongsQueueAction } from \"../Actions\";\n\nexport function songsQueue(\n  state: Song[] = [],\n  action: SongsQueueAction\n): Song[] {\n  switch (action.type) {\n    case Action.ADD_SONGS_TO_QUEUE:\n      return state.concat(action.songs);\n    case Action.TOGGLE_SONG_IN_QUEUE:\n      return state.map((song: Song) => {\n        if (song.name == action.songName) {\n          return {\n            ...song,\n            isReady: action.isReady\n          };\n        } else {\n          return song;\n        }\n      });\n    // this overrides whole array of songs\n    case Action.SAVE_SONGS_IN_QUEUE:\n      return action.songs;\n    case Action.DELETE_RECENT_ACTIVE_SONG_FROM_QUEUE:\n      if (state.length > 0) {\n        return state.slice(1, state.length);\n      } else {\n        return state;\n      }\n    default:\n      return state;\n  }\n}\n","import { Song, User, Token } from \"../Actions/index\";\nimport { ReduxState } from \"./index\";\n\nexport const initialState: ReduxState = {\n  token: <Token>{},\n  songs: [],\n  user: <User>{},\n  albums: [],\n  previousSongs: [],\n  activeSong: <Song>{},\n  websocketConnected: false,\n  songsQueue: []\n};\n","import React, { Component } from \"react\";\nimport { Song, Artist, SongReadiness } from \"../../Actions/index\";\nimport { List, Avatar, Icon } from \"antd\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\n\ninterface SongProps {\n  song: Song;\n  setActiveSong: (song: Song) => void;\n}\n\nexport function formatArtists(artists: Artist[]) {\n  return artists\n    .slice(0, 3)\n    .map(artist => artist.name)\n    .join(\", \");\n}\n\nfunction formatText(description: string) {\n  const maxNumberOfLetters = window.innerWidth / 10;\n  if (description.length > maxNumberOfLetters) {\n    return `${description.slice(0, maxNumberOfLetters)}...`;\n  } else {\n    return description;\n  }\n}\n\nexport class SongItem extends Component<SongProps> {\n  render() {\n    const { artists } = this.props.song;\n\n    return (\n      <List.Item\n        className=\"list-item-song\"\n        onClick={() => {\n          this.props.setActiveSong(this.props.song);\n        }}\n      >\n        <List.Item.Meta\n          avatar={<Avatar src={this.props.song.thumbnail_url} />}\n          title={\n            <span className=\"song-name\">\n              {formatText(this.props.song.name)}\n            </span>\n          }\n          description={formatText(artists)}\n        />\n      </List.Item>\n    );\n  }\n}\n\nexport class SongQueueItem extends Component<SongProps> {\n  render() {\n    const { artists } = this.props.song;\n    return (\n      <List.Item\n        className=\"list-item-song\"\n        onClick={() => {\n          this.props.setActiveSong(this.props.song);\n        }}\n      >\n        {formatProgress(this.props.song.isReady)}\n        <List.Item.Meta\n          avatar={<Avatar src={this.props.song.thumbnail_url} />}\n          title={\n            <span className=\"song-name\">\n              {formatText(this.props.song.name)}\n            </span>\n          }\n          description={formatText(artists)}\n        />\n      </List.Item>\n    );\n  }\n}\n\nconst progress = css({\n  fontSize: 24\n});\n\nconst failed = css({\n  color: \"#ba252f\"\n});\n\nconst success = css({\n  color: \"#15c455\"\n});\n\nfunction formatProgress(readiness: SongReadiness) {\n  switch (readiness) {\n    case SongReadiness.CANT_DOWNLOAD:\n      return (\n        <Icon\n          title=\"Song can't be downloaded\"\n          type=\"close-circle\"\n          css={[progress, failed]}\n        />\n      );\n    case SongReadiness.NOT_READY:\n      return (\n        <Icon title=\"Downloading song\" type=\"loading\" css={progress} spin />\n      );\n    case SongReadiness.READY:\n      return (\n        <Icon\n          type=\"check-circle\"\n          title=\"Song successfully downloaded\"\n          css={[progress, success]}\n        />\n      );\n  }\n}\n","import React, { Component } from \"react\";\nimport { Song, setActiveSong } from \"../../Actions/index\";\nimport { SongItem } from \"../Presentational/index\";\nimport { connect } from \"react-redux\";\nimport { ReduxState } from \"../../Stores/index\";\nimport { List, Menu, Input, notification } from \"antd\";\nimport { Dispatch } from \"redux\";\nimport { addSongsToQueue } from \"../../Actions/songsQueue\";\nimport { SongQueueItem } from \"../Presentational/Song\";\n/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\nimport { scheduleSong } from \"../../Actions/activeSong\";\n\nconst Search = Input.Search;\ntype SongListProps = {\n  songs: Song[];\n  songsQueue: Song[];\n  setActiveSong: (song: Song) => void;\n};\n\nenum SelectedList {\n  YourSongs = \"YourSongs\",\n  SongsQueue = \"SongsQueue\"\n}\n\ntype SongListState = {\n  offset: number;\n  currentPage: number;\n  window_height: number;\n  window_width: number;\n  selectedList: SelectedList;\n  searchbarValue: string;\n  indexesToFade: number[];\n};\n\nclass SongList extends Component<SongListProps, SongListState> {\n  state = {\n    offset: 0,\n    currentPage: 1,\n    window_height: window.innerHeight,\n    window_width: window.innerWidth,\n    selectedList: SelectedList.YourSongs,\n    searchbarValue: \"\",\n    indexesToFade: []\n  };\n\n  getData = (songs: Song[]) => {\n    if (this.state.searchbarValue.length === 0) {\n      return songs;\n    }\n    return songs.filter(song => {\n      const songName = song.name.toLowerCase();\n      const artists = song.artists.toLowerCase();\n      return (\n        songName.includes(this.state.searchbarValue) ||\n        artists.includes(this.state.searchbarValue)\n      );\n    });\n  };\n\n  handleTransition = (songs: Song[]) => {\n    return songs;\n  };\n\n  render() {\n    const songs =\n      this.state.selectedList === SelectedList.SongsQueue\n        ? this.getData(this.props.songsQueue)\n        : this.getData(this.props.songs);\n    return (\n      <div className=\"list-container\">\n        <Menu\n          onClick={e => {\n            const key =\n              e.key === \"YourSongs\"\n                ? SelectedList.YourSongs\n                : SelectedList.SongsQueue;\n            this.setState({ selectedList: key });\n          }}\n          selectedKeys={[this.state.selectedList]}\n          mode=\"horizontal\"\n        >\n          <Menu.Item key={SelectedList.YourSongs}>Your songs</Menu.Item>\n          <Menu.Item key={SelectedList.SongsQueue}>Songs queue</Menu.Item>\n        </Menu>\n        <Search\n          placeholder=\"filter songs...\"\n          size=\"default\"\n          name=\"domains\"\n          value={this.state.searchbarValue}\n          onChange={(e: any) => {\n            const { value } = e.target;\n            this.setState({ searchbarValue: value });\n          }}\n          onSearch={(name: string) => {\n            if (name.length == 0) {\n              return;\n            }\n          }}\n        />\n        <span>\n          <List\n            locale={{\n              emptyText:\n                this.state.selectedList === SelectedList.SongsQueue\n                  ? \"There are no songs scheduled in the queue\"\n                  : \"There are no favourite songs in your spotify account.\"\n            }}\n            bordered={false}\n            size={\"large\"}\n            itemLayout=\"horizontal\"\n            dataSource={songs}\n            renderItem={(song: Song) => {\n              if (this.state.selectedList === SelectedList.SongsQueue) {\n                return (\n                  <SongQueueItem\n                    setActiveSong={this.props.setActiveSong}\n                    song={song}\n                  />\n                );\n              } else {\n                return (\n                  <SongItem\n                    setActiveSong={this.props.setActiveSong}\n                    song={song}\n                  />\n                );\n              }\n            }}\n            pagination={{\n              total: songs.length,\n              pageSize: window.innerHeight / 110,\n              simple: true,\n              showQuickJumper: true\n            }}\n          />\n        </span>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    songs: state.songs,\n    songsQueue: state.songsQueue\n  };\n};\n\nconst dispatchToProps = (dispatch: Dispatch) => {\n  return {\n    setActiveSong: (song: Song) => {\n      // set song to be active, true indicates that we want to download it\n      notification.success({\n        description: song.formatted_name,\n        message: \"Successfully scheduled\",\n        duration: window.innerWidth >= 576 ? 2 : 1\n      });\n      scheduleSong(song);\n      dispatch(addSongsToQueue([song]));\n    }\n  };\n};\n\nconst SongListComponent = connect(\n  mapStateToProps,\n  dispatchToProps\n)(SongList);\n\nexport { SongListComponent as SongList };\n","/** @jsx jsx */ import { jsx, css } from \"@emotion/core\";\nimport React, { Component } from \"react\";\nimport { Song, isObjectEmpty } from \"../../Actions/index\";\nimport { Avatar, Slider } from \"antd\";\nimport { Dispatch } from \"redux\";\nimport { ReduxState } from \"../../Stores\";\nimport { connect } from \"react-redux\";\ntype MusicPlayerProps = {\n  previousSongs: Song[];\n  activeSong: Song;\n  nextSong: () => void;\n  previousSong: () => void;\n};\n\nfunction convertTime(time: number) {\n  const seconds = Math.floor(time);\n  const mins = Math.floor(seconds / 60);\n  const secondsRemaining = seconds - mins * 60;\n\n  // if seconds are less than 10 add 0 at the begining of the string so it looks like 0:01\n  return `${mins}:${\n    secondsRemaining < 10 ? `0${secondsRemaining}` : secondsRemaining\n  }`;\n}\n\nconst breakpoint = `@media (max-width: 576px)`;\n\nconst musicPlayer = css({\n  background: \"#282828\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"flex-end\",\n  width: \"100%\",\n  marginLeft: \"auto\",\n  marginRight: \"auto\",\n  flexWrap: \"wrap\",\n  padding: \"1rem 5% 1rem 5%\",\n  height: \"8rem\"\n  // [breakpoint]: {\n  //   padding: \"1rem 5% 1rem 5%\"\n  // }\n});\n\nconst playerTools = css({\n  width: \"100%\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"flex-end\"\n});\n\nclass MusicPlayer extends Component<MusicPlayerProps> {\n  state = {\n    progress: 0,\n    clicked: false\n  };\n\n  render() {\n    // const { duration_ms } = this.props.activeSong;\n    const isSongSet = !isObjectEmpty(this.props.activeSong);\n    return (\n      <div css={musicPlayer}>\n        {isSongSet && <ActiveSong activeSong={this.props.activeSong} />}\n        {isSongSet && <SongTimer duration={this.props.activeSong.duration} />}\n      </div>\n    );\n  }\n}\n\ntype SongTimerProps = {\n  duration: number;\n};\n\nconst songTimer = css({\n  width: \"30%\",\n  height: \"80%\"\n});\n\nclass SongTimer extends Component<SongTimerProps> {\n  state = {\n    progress: 0\n  };\n\n  constructor(props: any) {\n    super(props);\n    setInterval(\n      () => this.setState({ progress: this.state.progress + 1 }),\n      1000\n    );\n  }\n\n  componentWillReceiveProps(props: SongTimerProps) {\n    if (props.duration !== this.props.duration) {\n      this.setState({ progress: 0 });\n    }\n  }\n\n  render() {\n    const { duration } = this.props;\n    return (\n      <div css={songTimer}>\n        <div>\n          {convertTime(this.state.progress)} / {convertTime(duration)}\n        </div>\n      </div>\n    );\n  }\n}\n\ntype ActiveSongProps = {\n  activeSong: Song;\n};\n\nconst activeSong = css({\n  width: \"70%\",\n  height: \"80%\",\n  [breakpoint]: {\n    width: \"70%\"\n  }\n});\n\nclass ActiveSong extends Component<ActiveSongProps> {\n  render() {\n    return (\n      <div css={activeSong}>\n        <Avatar\n          size={50}\n          shape={\"square\"}\n          src={this.props.activeSong.thumbnail_url}\n        />\n        <div style={{ display: \"inline-block\", paddingLeft: \"0.5rem\" }}>\n          <div style={{ fontSize: \"0.9rem\", width: \"100%\" }}>\n            {this.props.activeSong.name}\n          </div>\n          <div style={{ fontSize: \"0.7rem\", width: \"100%\", color: \"#b3b3b3\" }}>\n            {this.props.activeSong.artists}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n// Music player's dispatch to props and state to props\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    songs: state.songs,\n    previousSongs: state.previousSongs,\n    activeSong: state.activeSong\n  };\n};\n\nconst dispatchToProps = (dispatch: Dispatch) => {\n  return {\n    // set some random song to be active and save it in previousSongs history\n    nextSong: () => {\n      // dispatch(setRandomSong(true));\n    },\n    // set last element of previousSongs array to be active song then pop it off\n    // if there are no elements in the previousSongs array a random song will be set to be active\n    previousSong: () => {\n      //dispatch(setPreviousSong());\n    }\n  };\n};\n\nexport const MusicPlayerComponent = connect(\n  mapStateToProps,\n  dispatchToProps\n)(MusicPlayer);\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport {\n  Login,\n  AuthRedirection as AuthRedirectionComponent\n} from \"./Components/index\";\nimport { Provider, connect } from \"react-redux\";\nimport { Dispatch } from \"redux\";\nimport { store, ReduxState } from \"./Stores/index\";\nimport {\n  saveToken,\n  getUserFavouriteSongs,\n  Token,\n  TokenStatus,\n  SongsState,\n  getTokenFromLocalStorage,\n  getUserAlbums,\n  getUserInformations\n} from \"./Actions/index\";\nimport { RouteComponentProps } from \"react-router-dom\";\nimport { SongList, MusicPlayer } from \"./Components/Containers/index\";\n\ninterface AppProps extends RouteComponentProps {\n  fetchUserInformations: () => void;\n  fetchUserAlbums: () => void;\n  fetchAlbumSongs: () => void;\n  fetchFavouriteSongs: () => void;\n  getTokenFromLocalStorage: () => void;\n  token: Token;\n  socketConnected: boolean;\n}\n\nclass App extends Component<AppProps> {\n  state = {\n    didRouteChange: false\n  };\n\n  componentDidMount() {\n    this.props.getTokenFromLocalStorage();\n  }\n\n  componentWillReceiveProps(props: AppProps) {\n    // didRouteChange is used to prevent infinite loops of props updates caused due to changed props of react-router\n    // if token got from local storage is expired redirect to login component\n    if (\n      props.token.status === TokenStatus.EXPIRED &&\n      !this.state.didRouteChange\n    ) {\n      this.props.history.push(\"/login\");\n      this.setState({ didRouteChange: true });\n    }\n    // if token got from local storage is not expired fetch needed data and redirect to component that lists songs\n    else if (\n      props.token.value.length > 0 &&\n      !this.state.didRouteChange &&\n      props.token.status !== TokenStatus.EXPIRED\n    ) {\n      this.props.fetchUserInformations();\n      this.props.fetchUserAlbums();\n      this.props.fetchFavouriteSongs();\n      this.props.history.push(\"/songs\");\n      this.setState({ didRouteChange: true });\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App-header\">\n        <Switch>\n          <Route path=\"/auth\" component={AuthRedirection} />\n          <Route path=\"/songs\" component={SongList} />\n          <Route path=\"/\" component={Login} />\n        </Switch>\n        {this.props.socketConnected && <MusicPlayer />}\n      </div>\n    );\n  }\n}\n\nclass Root extends Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <Router>\n          <Route path=\"/\" component={AppCore} />\n        </Router>\n      </Provider>\n    );\n  }\n}\n\nconst mapStateToProps = (state: ReduxState) => {\n  return {\n    token: state.token,\n    socketConnected: state.websocketConnected\n  };\n};\n\n// DTP - dispatch to props\nconst appDTP = (dispatch: Dispatch) => {\n  return {\n    fetchUserInformations: async () => {\n      dispatch(await getUserInformations());\n    },\n    fetchUserAlbums: async () => {\n      dispatch(await getUserAlbums());\n    },\n    fetchFavouriteSongs: async () => {\n      await getUserFavouriteSongs(dispatch);\n    },\n    getTokenFromLocalStorage: () => {\n      dispatch(getTokenFromLocalStorage());\n    }\n  };\n};\n\nconst AppCore = connect(\n  mapStateToProps,\n  appDTP\n)(App);\n\n// DTP - dispatch to props\n\nconst authRedirectionDTP = (dispatch: Dispatch) => {\n  return {\n    saveToken: (token: string) => {\n      dispatch(saveToken(token));\n    }\n  };\n};\n\nconst AuthRedirection = connect(\n  mapStateToProps,\n  authRedirectionDTP\n)(AuthRedirectionComponent);\n\nexport default Root;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Root from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { notification } from \"antd\";\nnotification.config({\n  placement: \"bottomRight\",\n  bottom: -5\n});\nReactDOM.render(<Root />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}